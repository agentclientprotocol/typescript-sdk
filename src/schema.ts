import { z } from "zod";

export const AGENT_METHODS = {
  authenticate: "authenticate",
  initialize: "initialize",
  session_cancel: "session/cancel",
  session_list: "session/list",
  session_load: "session/load",
  session_new: "session/new",
  session_prompt: "session/prompt",
  session_set_mode: "session/set_mode",
  session_set_model: "session/set_model",
} as const;

export const CLIENT_METHODS = {
  fs_read_text_file: "fs/read_text_file",
  fs_write_text_file: "fs/write_text_file",
  session_request_permission: "session/request_permission",
  session_update: "session/update",
  terminal_create: "terminal/create",
  terminal_kill: "terminal/kill",
  terminal_output: "terminal/output",
  terminal_release: "terminal/release",
  terminal_wait_for_exit: "terminal/wait_for_exit",
} as const;

export const PROTOCOL_VERSION = 1;

/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type AgentClientProtocol =
  | (AgentRequest | AgentResponse | AgentNotification)
  | (ClientRequest | ClientResponse | ClientNotification);
/**
 * JSON RPC Request Id
 *
 * An identifier established by the Client that MUST contain a String, Number, or NULL value if included. If it is not included it is assumed to be a notification. The value SHOULD normally not be Null [1] and Numbers SHOULD NOT contain fractional parts [2]
 *
 * The Server MUST reply with the same value in the Response object if included. This member is used to correlate the context between the two objects.
 *
 * [1] The use of Null as a value for the id member in a Request object is discouraged, because this specification uses a value of Null for Responses with an unknown id. Also, because JSON-RPC 1.0 uses an id value of Null for Notifications this could cause confusion in handling.
 *
 * [2] Fractional parts may be problematic, since many decimal fractions cannot be represented exactly as binary fractions.
 */
export type RequestId = null | number | string;
/**
 * A unique identifier for a conversation session between a client and agent.
 *
 * Sessions maintain their own context, conversation history, and state,
 * allowing multiple independent interactions with the same agent.
 *
 * See protocol docs: [Session ID](https://agentclientprotocol.com/protocol/session-setup#session-id)
 */
export type SessionId = string;
/**
 * The type of permission option being presented to the user.
 *
 * Helps clients choose appropriate icons and UI treatment.
 */
export type PermissionOptionKind =
  | "allow_once"
  | "allow_always"
  | "reject_once"
  | "reject_always";
/**
 * Unique identifier for a permission option.
 */
export type PermissionOptionId = string;
/**
 * Content produced by a tool call.
 *
 * Tool calls can produce different types of content including
 * standard content blocks (text, images) or file diffs.
 *
 * See protocol docs: [Content](https://agentclientprotocol.com/protocol/tool-calls#content)
 */
export type ToolCallContent = Content | Diff | Terminal;
/**
 * Content blocks represent displayable information in the Agent Client Protocol.
 *
 * They provide a structured way to handle various types of user-facing content—whether
 * it's text from language models, images for analysis, or embedded resources for context.
 *
 * Content blocks appear in:
 * - User prompts sent via `session/prompt`
 * - Language model output streamed through `session/update` notifications
 * - Progress updates and results from tool calls
 *
 * This structure is compatible with the Model Context Protocol (MCP), enabling
 * agents to seamlessly forward content from MCP tool outputs without transformation.
 *
 * See protocol docs: [Content](https://agentclientprotocol.com/protocol/content)
 */
export type ContentBlock =
  | TextContent
  | ImageContent
  | AudioContent
  | ResourceLink
  | EmbeddedResource;
/**
 * The sender or recipient of messages and data in a conversation.
 */
export type Role = "assistant" | "user";
/**
 * Resource content that can be embedded in a message.
 */
export type EmbeddedResourceResource =
  | TextResourceContents
  | BlobResourceContents;
/**
 * Categories of tools that can be invoked.
 *
 * Tool kinds help clients choose appropriate icons and optimize how they
 * display tool execution progress.
 *
 * See protocol docs: [Creating](https://agentclientprotocol.com/protocol/tool-calls#creating)
 */
export type ToolKind =
  | "read"
  | "edit"
  | "delete"
  | "move"
  | "search"
  | "execute"
  | "think"
  | "fetch"
  | "switch_mode"
  | "other";
/**
 * Execution status of a tool call.
 *
 * Tool calls progress through different statuses during their lifecycle.
 *
 * See protocol docs: [Status](https://agentclientprotocol.com/protocol/tool-calls#status)
 */
export type ToolCallStatus = "pending" | "in_progress" | "completed" | "failed";
/**
 * Unique identifier for a tool call within a session.
 */
export type ToolCallId = string;
export type AgentResponse =
  | {
      id: RequestId;
      /**
       * All possible responses that an agent can send to a client.
       *
       * This enum is used internally for routing RPC responses. You typically won't need
       * to use this directly - the responses are handled automatically by the connection.
       *
       * These are responses to the corresponding `ClientRequest` variants.
       */
      result:
        | InitializeResponse
        | AuthenticateResponse
        | NewSessionResponse
        | LoadSessionResponse
        | ListSessionsResponse
        | SetSessionModeResponse
        | PromptResponse
        | SetSessionModelResponse
        | ExtResponse;
    }
  | {
      error: Error;
      id: RequestId;
    };
/**
 * Protocol version identifier.
 *
 * This version is only bumped for breaking changes.
 * Non-breaking changes should be introduced via capabilities.
 */
export type ProtocolVersion = number;
/**
 * **UNSTABLE**
 *
 * This capability is not part of the spec yet, and may be removed or changed at any point.
 *
 * A unique identifier for a model.
 *
 * @experimental
 */
export type ModelId = string;
/**
 * Unique identifier for a Session Mode.
 */
export type SessionModeId = string;
/**
 * Reasons why an agent stops processing a prompt turn.
 *
 * See protocol docs: [Stop Reasons](https://agentclientprotocol.com/protocol/prompt-turn#stop-reasons)
 */
export type StopReason =
  | "end_turn"
  | "max_tokens"
  | "max_turn_requests"
  | "refusal"
  | "cancelled";
/**
 * Different types of updates that can be sent during session processing.
 *
 * These updates provide real-time feedback about the agent's progress.
 *
 * See protocol docs: [Agent Reports Output](https://agentclientprotocol.com/protocol/prompt-turn#3-agent-reports-output)
 */
export type SessionUpdate =
  | ContentChunk
  | ToolCall
  | ToolCallUpdate
  | Plan
  | AvailableCommandsUpdate
  | CurrentModeUpdate;
/**
 * Priority levels for plan entries.
 *
 * Used to indicate the relative importance or urgency of different
 * tasks in the execution plan.
 * See protocol docs: [Plan Entries](https://agentclientprotocol.com/protocol/agent-plan#plan-entries)
 */
export type PlanEntryPriority = "high" | "medium" | "low";
/**
 * Status of a plan entry in the execution flow.
 *
 * Tracks the lifecycle of each task from planning through completion.
 * See protocol docs: [Plan Entries](https://agentclientprotocol.com/protocol/agent-plan#plan-entries)
 */
export type PlanEntryStatus = "pending" | "in_progress" | "completed";
/**
 * The input specification for a command.
 */
export type AvailableCommandInput = UnstructuredCommandInput;
/**
 * Configuration for connecting to an MCP (Model Context Protocol) server.
 *
 * MCP servers provide tools and context that the agent can use when
 * processing prompts.
 *
 * See protocol docs: [MCP Servers](https://agentclientprotocol.com/protocol/session-setup#mcp-servers)
 */
export type McpServer = McpServerHttp | McpServerSse | McpServerStdio;
export type ClientResponse =
  | {
      id: RequestId;
      /**
       * All possible responses that a client can send to an agent.
       *
       * This enum is used internally for routing RPC responses. You typically won't need
       * to use this directly - the responses are handled automatically by the connection.
       *
       * These are responses to the corresponding `AgentRequest` variants.
       */
      result:
        | WriteTextFileResponse
        | ReadTextFileResponse
        | RequestPermissionResponse
        | CreateTerminalResponse
        | TerminalOutputResponse
        | ReleaseTerminalResponse
        | WaitForTerminalExitResponse
        | KillTerminalCommandResponse
        | ExtResponse;
    }
  | {
      error: Error;
      id: RequestId;
    };
/**
 * The outcome of a permission request.
 */
export type RequestPermissionOutcome =
  | {
      outcome: "cancelled";
    }
  | SelectedPermissionOutcome;

export interface AgentRequest {
  id: RequestId;
  method: string;
  params?:
    | (
        | WriteTextFileRequest
        | ReadTextFileRequest
        | RequestPermissionRequest
        | CreateTerminalRequest
        | TerminalOutputRequest
        | ReleaseTerminalRequest
        | WaitForTerminalExitRequest
        | KillTerminalCommandRequest
        | ExtRequest
      )
    | null;
}
/**
 * Request to write content to a text file.
 *
 * Only available if the client supports the `fs.writeTextFile` capability.
 */
export interface WriteTextFileRequest {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * The text content to write to the file.
   */
  content: string;
  /**
   * Absolute path to the file to write.
   */
  path: string;
  /**
   * The session ID for this request.
   */
  sessionId: SessionId;
}
/**
 * Request to read content from a text file.
 *
 * Only available if the client supports the `fs.readTextFile` capability.
 */
export interface ReadTextFileRequest {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * Maximum number of lines to read.
   */
  limit?: number | null;
  /**
   * Line number to start reading from (1-based).
   */
  line?: number | null;
  /**
   * Absolute path to the file to read.
   */
  path: string;
  /**
   * The session ID for this request.
   */
  sessionId: SessionId;
}
/**
 * Request for user permission to execute a tool call.
 *
 * Sent when the agent needs authorization before performing a sensitive operation.
 *
 * See protocol docs: [Requesting Permission](https://agentclientprotocol.com/protocol/tool-calls#requesting-permission)
 */
export interface RequestPermissionRequest {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * Available permission options for the user to choose from.
   */
  options: PermissionOption[];
  /**
   * The session ID for this request.
   */
  sessionId: SessionId;
  /**
   * Details about the tool call requiring permission.
   */
  toolCall: ToolCallUpdate;
}
/**
 * An option presented to the user when requesting permission.
 */
export interface PermissionOption {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * Hint about the nature of this permission option.
   */
  kind: PermissionOptionKind;
  /**
   * Human-readable label to display to the user.
   */
  name: string;
  /**
   * Unique identifier for this permission option.
   */
  optionId: PermissionOptionId;
}
/**
 * An update to an existing tool call.
 *
 * Used to report progress and results as tools execute. All fields except
 * the tool call ID are optional - only changed fields need to be included.
 *
 * See protocol docs: [Updating](https://agentclientprotocol.com/protocol/tool-calls#updating)
 */
export interface ToolCallUpdate {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * Replace the content collection.
   */
  content?: ToolCallContent[] | null;
  /**
   * Update the tool kind.
   */
  kind?: ToolKind | null;
  /**
   * Replace the locations collection.
   */
  locations?: ToolCallLocation[] | null;
  /**
   * Update the raw input.
   */
  rawInput?: {
    [k: string]: unknown | undefined;
  };
  /**
   * Update the raw output.
   */
  rawOutput?: {
    [k: string]: unknown | undefined;
  };
  /**
   * Update the execution status.
   */
  status?: ToolCallStatus | null;
  /**
   * Update the human-readable title.
   */
  title?: string | null;
  /**
   * The ID of the tool call being updated.
   */
  toolCallId: ToolCallId;
}
/**
 * Standard content block (text, images, resources).
 */
export interface Content {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * The actual content block.
   */
  content: ContentBlock;
}
/**
 * Text provided to or from an LLM.
 */
export interface TextContent {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  annotations?: Annotations | null;
  text: string;
}
/**
 * Optional annotations for the client. The client can use annotations to inform how objects are used or displayed
 */
export interface Annotations {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  audience?: Role[] | null;
  lastModified?: string | null;
  priority?: number | null;
}
/**
 * An image provided to or from an LLM.
 */
export interface ImageContent {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  annotations?: Annotations | null;
  data: string;
  mimeType: string;
  uri?: string | null;
}
/**
 * Audio provided to or from an LLM.
 */
export interface AudioContent {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  annotations?: Annotations | null;
  data: string;
  mimeType: string;
}
/**
 * A resource that the server is capable of reading, included in a prompt or tool call result.
 */
export interface ResourceLink {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  annotations?: Annotations | null;
  description?: string | null;
  mimeType?: string | null;
  name: string;
  size?: number | null;
  title?: string | null;
  uri: string;
}
/**
 * The contents of a resource, embedded into a prompt or tool call result.
 */
export interface EmbeddedResource {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  annotations?: Annotations | null;
  resource: EmbeddedResourceResource;
}
/**
 * Text-based resource contents.
 */
export interface TextResourceContents {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  mimeType?: string | null;
  text: string;
  uri: string;
}
/**
 * Binary resource contents.
 */
export interface BlobResourceContents {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  blob: string;
  mimeType?: string | null;
  uri: string;
}
/**
 * A diff representing file modifications.
 *
 * Shows changes to files in a format suitable for display in the client UI.
 *
 * See protocol docs: [Content](https://agentclientprotocol.com/protocol/tool-calls#content)
 */
export interface Diff {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * The new content after modification.
   */
  newText: string;
  /**
   * The original content (None for new files).
   */
  oldText?: string | null;
  /**
   * The file path being modified.
   */
  path: string;
}
/**
 * Embed a terminal created with `terminal/create` by its id.
 *
 * The terminal must be added before calling `terminal/release`.
 *
 * See protocol docs: [Terminal](https://agentclientprotocol.com/protocol/terminals)
 */
export interface Terminal {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  terminalId: string;
}
/**
 * A file location being accessed or modified by a tool.
 *
 * Enables clients to implement "follow-along" features that track
 * which files the agent is working with in real-time.
 *
 * See protocol docs: [Following the Agent](https://agentclientprotocol.com/protocol/tool-calls#following-the-agent)
 */
export interface ToolCallLocation {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * Optional line number within the file.
   */
  line?: number | null;
  /**
   * The file path being accessed or modified.
   */
  path: string;
}
/**
 * Request to create a new terminal and execute a command.
 */
export interface CreateTerminalRequest {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * Array of command arguments.
   */
  args?: string[];
  /**
   * The command to execute.
   */
  command: string;
  /**
   * Working directory for the command (absolute path).
   */
  cwd?: string | null;
  /**
   * Environment variables for the command.
   */
  env?: EnvVariable[];
  /**
   * Maximum number of output bytes to retain.
   *
   * When the limit is exceeded, the Client truncates from the beginning of the output
   * to stay within the limit.
   *
   * The Client MUST ensure truncation happens at a character boundary to maintain valid
   * string output, even if this means the retained output is slightly less than the
   * specified limit.
   */
  outputByteLimit?: number | null;
  /**
   * The session ID for this request.
   */
  sessionId: SessionId;
}
/**
 * An environment variable to set when launching an MCP server.
 */
export interface EnvVariable {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * The name of the environment variable.
   */
  name: string;
  /**
   * The value to set for the environment variable.
   */
  value: string;
}
/**
 * Request to get the current output and status of a terminal.
 */
export interface TerminalOutputRequest {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * The session ID for this request.
   */
  sessionId: SessionId;
  /**
   * The ID of the terminal to get output from.
   */
  terminalId: string;
}
/**
 * Request to release a terminal and free its resources.
 */
export interface ReleaseTerminalRequest {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * The session ID for this request.
   */
  sessionId: SessionId;
  /**
   * The ID of the terminal to release.
   */
  terminalId: string;
}
/**
 * Request to wait for a terminal command to exit.
 */
export interface WaitForTerminalExitRequest {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * The session ID for this request.
   */
  sessionId: SessionId;
  /**
   * The ID of the terminal to wait for.
   */
  terminalId: string;
}
/**
 * Request to kill a terminal command without releasing the terminal.
 */
export interface KillTerminalCommandRequest {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * The session ID for this request.
   */
  sessionId: SessionId;
  /**
   * The ID of the terminal to kill.
   */
  terminalId: string;
}
/**
 * Allows for sending an arbitrary request that is not part of the ACP spec.
 * Extension methods provide a way to add custom functionality while maintaining
 * protocol compatibility.
 *
 * See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
 */
export interface ExtRequest {
  [k: string]: unknown | undefined;
}
/**
 * Response to the `initialize` method.
 *
 * Contains the negotiated protocol version and agent capabilities.
 *
 * See protocol docs: [Initialization](https://agentclientprotocol.com/protocol/initialization)
 */
export interface InitializeResponse {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * Capabilities supported by the agent.
   */
  agentCapabilities?: AgentCapabilities;
  /**
   * Information about the Agent name and version sent to the Client.
   *
   * Note: in future versions of the protocol, this will be required.
   */
  agentInfo?: Implementation | null;
  /**
   * Authentication methods supported by the agent.
   */
  authMethods?: AuthMethod[];
  /**
   * The protocol version the client specified if supported by the agent,
   * or the latest protocol version supported by the agent.
   *
   * The client should disconnect, if it doesn't support this version.
   */
  protocolVersion: ProtocolVersion;
}
/**
 * Capabilities supported by the agent.
 *
 * Advertised during initialization to inform the client about
 * available features and content types.
 *
 * See protocol docs: [Agent Capabilities](https://agentclientprotocol.com/protocol/initialization#agent-capabilities)
 */
export interface AgentCapabilities {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * Whether the agent supports `session/load`.
   */
  loadSession?: boolean;
  /**
   * MCP capabilities supported by the agent.
   */
  mcpCapabilities?: McpCapabilities;
  /**
   * Prompt capabilities supported by the agent.
   */
  promptCapabilities?: PromptCapabilities;
  sessionCapabilities?: SessionCapabilities;
}
/**
 * MCP capabilities supported by the agent
 */
export interface McpCapabilities {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * Agent supports [`McpServer::Http`].
   */
  http?: boolean;
  /**
   * Agent supports [`McpServer::Sse`].
   */
  sse?: boolean;
}
/**
 * Prompt capabilities supported by the agent in `session/prompt` requests.
 *
 * Baseline agent functionality requires support for [`ContentBlock::Text`]
 * and [`ContentBlock::ResourceLink`] in prompt requests.
 *
 * Other variants must be explicitly opted in to.
 * Capabilities for different types of content in prompt requests.
 *
 * Indicates which content types beyond the baseline (text and resource links)
 * the agent can process.
 *
 * See protocol docs: [Prompt Capabilities](https://agentclientprotocol.com/protocol/initialization#prompt-capabilities)
 */
export interface PromptCapabilities {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * Agent supports [`ContentBlock::Audio`].
   */
  audio?: boolean;
  /**
   * Agent supports embedded context in `session/prompt` requests.
   *
   * When enabled, the Client is allowed to include [`ContentBlock::Resource`]
   * in prompt requests for pieces of context that are referenced in the message.
   */
  embeddedContext?: boolean;
  /**
   * Agent supports [`ContentBlock::Image`].
   */
  image?: boolean;
}
/**
 * Session capabilities supported by the agent.
 *
 * As a baseline, all Agents **MUST** support `session/new`, `session/prompt`, `session/cancel`, and `session/update`.
 *
 * Optionally, they **MAY** support other session methods and notifications by specifying additional capabilities.
 *
 * Note: `session/load` is still handled by the top-level `load_session` capability. This will be unified in future versions of the protocol.
 *
 * See protocol docs: [Session Capabilities](https://agentclientprotocol.com/protocol/initialization#session-capabilities)
 */
export interface SessionCapabilities {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * **UNSTABLE**
   *
   * This capability is not part of the spec yet, and may be removed or changed at any point.
   *
   * Whether the agent supports `session/list`.
   *
   * @experimental
   */
  list?: SessionListCapabilities | null;
}
/**
 * Capabilities for the `session/list` method.
 *
 * By supplying `{}` it means that the agent supports listing of sessions.
 *
 * Further capabilities can be added in the future for other means of filtering or searching the list.
 */
export interface SessionListCapabilities {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
}
/**
 * Metadata about the implementation of the client or agent.
 * Describes the name and version of an MCP implementation, with an optional
 * title for UI representation.
 */
export interface Implementation {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * Intended for programmatic or logical use, but can be used as a display
   * name fallback if title isn’t present.
   */
  name: string;
  /**
   * Intended for UI and end-user contexts — optimized to be human-readable
   * and easily understood.
   *
   * If not provided, the name should be used for display.
   */
  title?: string | null;
  /**
   * Version of the implementation. Can be displayed to the user or used
   * for debugging or metrics purposes. (e.g. "1.0.0").
   */
  version: string;
}
/**
 * Describes an available authentication method.
 */
export interface AuthMethod {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * Optional description providing more details about this authentication method.
   */
  description?: string | null;
  /**
   * Unique identifier for this authentication method.
   */
  id: string;
  /**
   * Human-readable name of the authentication method.
   */
  name: string;
}
/**
 * Response to the `authenticate` method.
 */
export interface AuthenticateResponse {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
}
/**
 * Response from creating a new session.
 *
 * See protocol docs: [Creating a Session](https://agentclientprotocol.com/protocol/session-setup#creating-a-session)
 */
export interface NewSessionResponse {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * **UNSTABLE**
   *
   * This capability is not part of the spec yet, and may be removed or changed at any point.
   *
   * Initial model state if supported by the Agent
   *
   * @experimental
   */
  models?: SessionModelState | null;
  /**
   * Initial mode state if supported by the Agent
   *
   * See protocol docs: [Session Modes](https://agentclientprotocol.com/protocol/session-modes)
   */
  modes?: SessionModeState | null;
  /**
   * Unique identifier for the created session.
   *
   * Used in all subsequent requests for this conversation.
   */
  sessionId: SessionId;
}
/**
 * **UNSTABLE**
 *
 * This capability is not part of the spec yet, and may be removed or changed at any point.
 *
 * The set of models and the one currently active.
 *
 * @experimental
 */
export interface SessionModelState {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * The set of models that the Agent can use
   */
  availableModels: ModelInfo[];
  /**
   * The current model the Agent is in.
   */
  currentModelId: ModelId;
}
/**
 * **UNSTABLE**
 *
 * This capability is not part of the spec yet, and may be removed or changed at any point.
 *
 * Information about a selectable model.
 *
 * @experimental
 */
export interface ModelInfo {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * Optional description of the model.
   */
  description?: string | null;
  /**
   * Unique identifier for the model.
   */
  modelId: ModelId;
  /**
   * Human-readable name of the model.
   */
  name: string;
}
/**
 * The set of modes and the one currently active.
 */
export interface SessionModeState {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * The set of modes that the Agent can operate in
   */
  availableModes: SessionMode[];
  /**
   * The current mode the Agent is in.
   */
  currentModeId: SessionModeId;
}
/**
 * A mode the agent can operate in.
 *
 * See protocol docs: [Session Modes](https://agentclientprotocol.com/protocol/session-modes)
 */
export interface SessionMode {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  description?: string | null;
  id: SessionModeId;
  name: string;
}
/**
 * Response from loading an existing session.
 */
export interface LoadSessionResponse {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * **UNSTABLE**
   *
   * This capability is not part of the spec yet, and may be removed or changed at any point.
   *
   * Initial model state if supported by the Agent
   *
   * @experimental
   */
  models?: SessionModelState | null;
  /**
   * Initial mode state if supported by the Agent
   *
   * See protocol docs: [Session Modes](https://agentclientprotocol.com/protocol/session-modes)
   */
  modes?: SessionModeState | null;
}
/**
 * **UNSTABLE**
 *
 * This capability is not part of the spec yet, and may be removed or changed at any point.
 *
 * Response from listing sessions.
 *
 * @experimental
 */
export interface ListSessionsResponse {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * Opaque cursor token. If present, pass this in the next request's cursor parameter
   * to fetch the next page. If absent, there are no more results.
   */
  nextCursor?: string | null;
  /**
   * Array of session information objects
   */
  sessions: SessionInfo[];
}
/**
 * **UNSTABLE**
 *
 * This capability is not part of the spec yet, and may be removed or changed at any point.
 *
 * Information about a session returned by session/list
 *
 * @experimental
 */
export interface SessionInfo {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * The working directory for this session. Must be an absolute path.
   */
  cwd: string;
  /**
   * Unique identifier for the session
   */
  sessionId: SessionId;
  /**
   * Human-readable title for the session
   */
  title?: string | null;
  /**
   * ISO 8601 timestamp of last activity
   */
  updatedAt?: string | null;
}
/**
 * Response to `session/set_mode` method.
 */
export interface SetSessionModeResponse {
  _meta?: unknown;
}
/**
 * Response from processing a user prompt.
 *
 * See protocol docs: [Check for Completion](https://agentclientprotocol.com/protocol/prompt-turn#4-check-for-completion)
 */
export interface PromptResponse {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * Indicates why the agent stopped processing the turn.
   */
  stopReason: StopReason;
}
/**
 * **UNSTABLE**
 *
 * This capability is not part of the spec yet, and may be removed or changed at any point.
 *
 * Response to `session/set_model` method.
 *
 * @experimental
 */
export interface SetSessionModelResponse {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
}
/**
 * Allows for sending an arbitrary response to an [`ExtRequest`] that is not part of the ACP spec.
 * Extension methods provide a way to add custom functionality while maintaining
 * protocol compatibility.
 *
 * See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
 */
export interface ExtResponse {
  [k: string]: unknown | undefined;
}
/**
 * JSON-RPC error object.
 *
 * Represents an error that occurred during method execution, following the
 * JSON-RPC 2.0 error object specification with optional additional data.
 *
 * See protocol docs: [JSON-RPC Error Object](https://www.jsonrpc.org/specification#error_object)
 */
export interface Error {
  /**
   * A number indicating the error type that occurred.
   * This must be an integer as defined in the JSON-RPC specification.
   */
  code: number;
  /**
   * Optional primitive or structured value that contains additional information about the error.
   * This may include debugging information or context-specific details.
   */
  data?: {
    [k: string]: unknown | undefined;
  };
  /**
   * A string providing a short description of the error.
   * The message should be limited to a concise single sentence.
   */
  message: string;
}
export interface AgentNotification {
  method: string;
  params?: (SessionNotification | ExtNotification) | null;
}
/**
 * Notification containing a session update from the agent.
 *
 * Used to stream real-time progress and results during prompt processing.
 *
 * See protocol docs: [Agent Reports Output](https://agentclientprotocol.com/protocol/prompt-turn#3-agent-reports-output)
 */
export interface SessionNotification {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * The ID of the session this update pertains to.
   */
  sessionId: SessionId;
  /**
   * The actual update content.
   */
  update: SessionUpdate;
}
/**
 * A streamed item of content
 */
export interface ContentChunk {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * A single item of content
   */
  content: ContentBlock;
}
/**
 * Represents a tool call that the language model has requested.
 *
 * Tool calls are actions that the agent executes on behalf of the language model,
 * such as reading files, executing code, or fetching data from external sources.
 *
 * See protocol docs: [Tool Calls](https://agentclientprotocol.com/protocol/tool-calls)
 */
export interface ToolCall {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * Content produced by the tool call.
   */
  content?: ToolCallContent[];
  /**
   * The category of tool being invoked.
   * Helps clients choose appropriate icons and UI treatment.
   */
  kind?: ToolKind;
  /**
   * File locations affected by this tool call.
   * Enables "follow-along" features in clients.
   */
  locations?: ToolCallLocation[];
  /**
   * Raw input parameters sent to the tool.
   */
  rawInput?: {
    [k: string]: unknown | undefined;
  };
  /**
   * Raw output returned by the tool.
   */
  rawOutput?: {
    [k: string]: unknown | undefined;
  };
  /**
   * Current execution status of the tool call.
   */
  status?: ToolCallStatus;
  /**
   * Human-readable title describing what the tool is doing.
   */
  title: string;
  /**
   * Unique identifier for this tool call within the session.
   */
  toolCallId: ToolCallId;
}
/**
 * An execution plan for accomplishing complex tasks.
 *
 * Plans consist of multiple entries representing individual tasks or goals.
 * Agents report plans to clients to provide visibility into their execution strategy.
 * Plans can evolve during execution as the agent discovers new requirements or completes tasks.
 *
 * See protocol docs: [Agent Plan](https://agentclientprotocol.com/protocol/agent-plan)
 */
export interface Plan {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * The list of tasks to be accomplished.
   *
   * When updating a plan, the agent must send a complete list of all entries
   * with their current status. The client replaces the entire plan with each update.
   */
  entries: PlanEntry[];
}
/**
 * A single entry in the execution plan.
 *
 * Represents a task or goal that the assistant intends to accomplish
 * as part of fulfilling the user's request.
 * See protocol docs: [Plan Entries](https://agentclientprotocol.com/protocol/agent-plan#plan-entries)
 */
export interface PlanEntry {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * Human-readable description of what this task aims to accomplish.
   */
  content: string;
  /**
   * The relative importance of this task.
   * Used to indicate which tasks are most critical to the overall goal.
   */
  priority: PlanEntryPriority;
  /**
   * Current execution status of this task.
   */
  status: PlanEntryStatus;
}
/**
 * Available commands are ready or have changed
 */
export interface AvailableCommandsUpdate {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * Commands the agent can execute
   */
  availableCommands: AvailableCommand[];
}
/**
 * Information about a command.
 */
export interface AvailableCommand {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * Human-readable description of what the command does.
   */
  description: string;
  /**
   * Input for the command if required
   */
  input?: AvailableCommandInput | null;
  /**
   * Command name (e.g., `create_plan`, `research_codebase`).
   */
  name: string;
}
/**
 * All text that was typed after the command name is provided as input.
 */
export interface UnstructuredCommandInput {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * A hint to display when the input hasn't been provided yet
   */
  hint: string;
}
/**
 * The current mode of the session has changed
 *
 * See protocol docs: [Session Modes](https://agentclientprotocol.com/protocol/session-modes)
 */
export interface CurrentModeUpdate {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * The ID of the current mode
   */
  currentModeId: SessionModeId;
}
/**
 * Allows the Agent to send an arbitrary notification that is not part of the ACP spec.
 * Extension notifications provide a way to send one-way messages for custom functionality
 * while maintaining protocol compatibility.
 *
 * See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
 */
export interface ExtNotification {
  [k: string]: unknown | undefined;
}
export interface ClientRequest {
  id: RequestId;
  method: string;
  params?:
    | (
        | InitializeRequest
        | AuthenticateRequest
        | NewSessionRequest
        | LoadSessionRequest
        | ListSessionsRequest
        | SetSessionModeRequest
        | PromptRequest
        | SetSessionModelRequest
        | ExtRequest
      )
    | null;
}
/**
 * Request parameters for the initialize method.
 *
 * Sent by the client to establish connection and negotiate capabilities.
 *
 * See protocol docs: [Initialization](https://agentclientprotocol.com/protocol/initialization)
 */
export interface InitializeRequest {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * Capabilities supported by the client.
   */
  clientCapabilities?: ClientCapabilities;
  /**
   * Information about the Client name and version sent to the Agent.
   *
   * Note: in future versions of the protocol, this will be required.
   */
  clientInfo?: Implementation | null;
  /**
   * The latest protocol version supported by the client.
   */
  protocolVersion: ProtocolVersion;
}
/**
 * Capabilities supported by the client.
 *
 * Advertised during initialization to inform the agent about
 * available features and methods.
 *
 * See protocol docs: [Client Capabilities](https://agentclientprotocol.com/protocol/initialization#client-capabilities)
 */
export interface ClientCapabilities {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * File system capabilities supported by the client.
   * Determines which file operations the agent can request.
   */
  fs?: FileSystemCapability;
  /**
   * Whether the Client support all `terminal/*` methods.
   */
  terminal?: boolean;
}
/**
 * Filesystem capabilities supported by the client.
 * File system capabilities that a client may support.
 *
 * See protocol docs: [FileSystem](https://agentclientprotocol.com/protocol/initialization#filesystem)
 */
export interface FileSystemCapability {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * Whether the Client supports `fs/read_text_file` requests.
   */
  readTextFile?: boolean;
  /**
   * Whether the Client supports `fs/write_text_file` requests.
   */
  writeTextFile?: boolean;
}
/**
 * Request parameters for the authenticate method.
 *
 * Specifies which authentication method to use.
 */
export interface AuthenticateRequest {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * The ID of the authentication method to use.
   * Must be one of the methods advertised in the initialize response.
   */
  methodId: string;
}
/**
 * Request parameters for creating a new session.
 *
 * See protocol docs: [Creating a Session](https://agentclientprotocol.com/protocol/session-setup#creating-a-session)
 */
export interface NewSessionRequest {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * The working directory for this session. Must be an absolute path.
   */
  cwd: string;
  /**
   * List of MCP (Model Context Protocol) servers the agent should connect to.
   */
  mcpServers: McpServer[];
}
/**
 * HTTP transport configuration for MCP.
 */
export interface McpServerHttp {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * HTTP headers to set when making requests to the MCP server.
   */
  headers: HttpHeader[];
  /**
   * Human-readable name identifying this MCP server.
   */
  name: string;
  /**
   * URL to the MCP server.
   */
  url: string;
}
/**
 * An HTTP header to set when making requests to the MCP server.
 */
export interface HttpHeader {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * The name of the HTTP header.
   */
  name: string;
  /**
   * The value to set for the HTTP header.
   */
  value: string;
}
/**
 * SSE transport configuration for MCP.
 */
export interface McpServerSse {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * HTTP headers to set when making requests to the MCP server.
   */
  headers: HttpHeader[];
  /**
   * Human-readable name identifying this MCP server.
   */
  name: string;
  /**
   * URL to the MCP server.
   */
  url: string;
}
/**
 * Stdio transport configuration for MCP.
 */
export interface McpServerStdio {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * Command-line arguments to pass to the MCP server.
   */
  args: string[];
  /**
   * Path to the MCP server executable.
   */
  command: string;
  /**
   * Environment variables to set when launching the MCP server.
   */
  env: EnvVariable[];
  /**
   * Human-readable name identifying this MCP server.
   */
  name: string;
}
/**
 * Request parameters for loading an existing session.
 *
 * Only available if the Agent supports the `loadSession` capability.
 *
 * See protocol docs: [Loading Sessions](https://agentclientprotocol.com/protocol/session-setup#loading-sessions)
 */
export interface LoadSessionRequest {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * The working directory for this session.
   */
  cwd: string;
  /**
   * List of MCP servers to connect to for this session.
   */
  mcpServers: McpServer[];
  /**
   * The ID of the session to load.
   */
  sessionId: SessionId;
}
/**
 * **UNSTABLE**
 *
 * This capability is not part of the spec yet, and may be removed or changed at any point.
 *
 * Request parameters for listing existing sessions.
 *
 * Only available if the Agent supports the `listSessions` capability.
 *
 * @experimental
 */
export interface ListSessionsRequest {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * Opaque cursor token from a previous response's nextCursor field for cursor-based pagination
   */
  cursor?: string | null;
  /**
   * Filter sessions by working directory. Must be an absolute path.
   */
  cwd?: string | null;
}
/**
 * Request parameters for setting a session mode.
 */
export interface SetSessionModeRequest {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * The ID of the mode to set.
   */
  modeId: SessionModeId;
  /**
   * The ID of the session to set the mode for.
   */
  sessionId: SessionId;
}
/**
 * Request parameters for sending a user prompt to the agent.
 *
 * Contains the user's message and any additional context.
 *
 * See protocol docs: [User Message](https://agentclientprotocol.com/protocol/prompt-turn#1-user-message)
 */
export interface PromptRequest {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * The blocks of content that compose the user's message.
   *
   * As a baseline, the Agent MUST support [`ContentBlock::Text`] and [`ContentBlock::ResourceLink`],
   * while other variants are optionally enabled via [`PromptCapabilities`].
   *
   * The Client MUST adapt its interface according to [`PromptCapabilities`].
   *
   * The client MAY include referenced pieces of context as either
   * [`ContentBlock::Resource`] or [`ContentBlock::ResourceLink`].
   *
   * When available, [`ContentBlock::Resource`] is preferred
   * as it avoids extra round-trips and allows the message to include
   * pieces of context from sources the agent may not have access to.
   */
  prompt: ContentBlock[];
  /**
   * The ID of the session to send this user message to
   */
  sessionId: SessionId;
}
/**
 * **UNSTABLE**
 *
 * This capability is not part of the spec yet, and may be removed or changed at any point.
 *
 * Request parameters for setting a session model.
 *
 * @experimental
 */
export interface SetSessionModelRequest {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * The ID of the model to set.
   */
  modelId: ModelId;
  /**
   * The ID of the session to set the model for.
   */
  sessionId: SessionId;
}
/**
 * Response to `fs/write_text_file`
 */
export interface WriteTextFileResponse {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
}
/**
 * Response containing the contents of a text file.
 */
export interface ReadTextFileResponse {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  content: string;
}
/**
 * Response to a permission request.
 */
export interface RequestPermissionResponse {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * The user's decision on the permission request.
   */
  outcome: RequestPermissionOutcome;
}
/**
 * The user selected one of the provided options.
 */
export interface SelectedPermissionOutcome {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * The ID of the option the user selected.
   */
  optionId: PermissionOptionId;
}
/**
 * Response containing the ID of the created terminal.
 */
export interface CreateTerminalResponse {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * The unique identifier for the created terminal.
   */
  terminalId: string;
}
/**
 * Response containing the terminal output and exit status.
 */
export interface TerminalOutputResponse {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * Exit status if the command has completed.
   */
  exitStatus?: TerminalExitStatus | null;
  /**
   * The terminal output captured so far.
   */
  output: string;
  /**
   * Whether the output was truncated due to byte limits.
   */
  truncated: boolean;
}
/**
 * Exit status of a terminal command.
 */
export interface TerminalExitStatus {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * The process exit code (may be null if terminated by signal).
   */
  exitCode?: number | null;
  /**
   * The signal that terminated the process (may be null if exited normally).
   */
  signal?: string | null;
}
/**
 * Response to terminal/release method
 */
export interface ReleaseTerminalResponse {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
}
/**
 * Response containing the exit status of a terminal command.
 */
export interface WaitForTerminalExitResponse {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * The process exit code (may be null if terminated by signal).
   */
  exitCode?: number | null;
  /**
   * The signal that terminated the process (may be null if exited normally).
   */
  signal?: string | null;
}
/**
 * Response to terminal/kill command method
 */
export interface KillTerminalCommandResponse {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
}
export interface ClientNotification {
  method: string;
  params?: (CancelNotification | ExtNotification) | null;
}
/**
 * Notification to cancel ongoing operations for a session.
 *
 * See protocol docs: [Cancellation](https://agentclientprotocol.com/protocol/prompt-turn#cancellation)
 */
export interface CancelNotification {
  /**
   * Extension point for implementations
   */
  _meta?: {
    [k: string]: unknown | undefined;
  };
  /**
   * The ID of the session to cancel operations for.
   */
  sessionId: SessionId;
}

/** @internal */
export const requestIdSchema = z.union([z.number(), z.string()]).nullable();

/** @internal */
export const sessionIdSchema = z.string();

/** @internal */
export const permissionOptionKindSchema = z.union([
  z.literal("allow_once"),
  z.literal("allow_always"),
  z.literal("reject_once"),
  z.literal("reject_always"),
]);

/** @internal */
export const permissionOptionIdSchema = z.string();

/** @internal */
export const diffSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  newText: z.string(),
  oldText: z.string().optional().nullable(),
  path: z.string(),
});

/** @internal */
export const terminalSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  terminalId: z.string(),
});

/** @internal */
export const roleSchema = z.union([z.literal("assistant"), z.literal("user")]);

/** @internal */
export const textResourceContentsSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  mimeType: z.string().optional().nullable(),
  text: z.string(),
  uri: z.string(),
});

/** @internal */
export const blobResourceContentsSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  blob: z.string(),
  mimeType: z.string().optional().nullable(),
  uri: z.string(),
});

/** @internal */
export const toolKindSchema = z.union([
  z.literal("read"),
  z.literal("edit"),
  z.literal("delete"),
  z.literal("move"),
  z.literal("search"),
  z.literal("execute"),
  z.literal("think"),
  z.literal("fetch"),
  z.literal("switch_mode"),
  z.literal("other"),
]);

/** @internal */
export const toolCallStatusSchema = z.union([
  z.literal("pending"),
  z.literal("in_progress"),
  z.literal("completed"),
  z.literal("failed"),
]);

/** @internal */
export const toolCallIdSchema = z.string();

/** @internal */
export const authenticateResponseSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
});

/** @internal */
export const setSessionModeResponseSchema = z.object({
  _meta: z.unknown().optional(),
});

/** @internal */
export const setSessionModelResponseSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
});

/** @internal */
export const extResponseSchema = z.record(
  z.union([z.unknown(), z.undefined()]),
);

/** @internal */
export const errorSchema = z.object({
  code: z.number(),
  data: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  message: z.string(),
});

/** @internal */
export const protocolVersionSchema = z.number();

/** @internal */
export const modelIdSchema = z.string();

/** @internal */
export const sessionModeIdSchema = z.string();

/** @internal */
export const stopReasonSchema = z.union([
  z.literal("end_turn"),
  z.literal("max_tokens"),
  z.literal("max_turn_requests"),
  z.literal("refusal"),
  z.literal("cancelled"),
]);

/** @internal */
export const currentModeUpdateSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  currentModeId: sessionModeIdSchema,
});

/** @internal */
export const planEntryPrioritySchema = z.union([
  z.literal("high"),
  z.literal("medium"),
  z.literal("low"),
]);

/** @internal */
export const planEntryStatusSchema = z.union([
  z.literal("pending"),
  z.literal("in_progress"),
  z.literal("completed"),
]);

/** @internal */
export const unstructuredCommandInputSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  hint: z.string(),
});

/** @internal */
export const writeTextFileResponseSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
});

/** @internal */
export const readTextFileResponseSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  content: z.string(),
});

/** @internal */
export const createTerminalResponseSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  terminalId: z.string(),
});

/** @internal */
export const releaseTerminalResponseSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
});

/** @internal */
export const waitForTerminalExitResponseSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  exitCode: z.number().optional().nullable(),
  signal: z.string().optional().nullable(),
});

/** @internal */
export const killTerminalCommandResponseSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
});

/** @internal */
export const selectedPermissionOutcomeSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  optionId: permissionOptionIdSchema,
});

/** @internal */
export const writeTextFileRequestSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  content: z.string(),
  path: z.string(),
  sessionId: sessionIdSchema,
});

/** @internal */
export const readTextFileRequestSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  limit: z.number().optional().nullable(),
  line: z.number().optional().nullable(),
  path: z.string(),
  sessionId: sessionIdSchema,
});

/** @internal */
export const terminalOutputRequestSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  sessionId: sessionIdSchema,
  terminalId: z.string(),
});

/** @internal */
export const releaseTerminalRequestSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  sessionId: sessionIdSchema,
  terminalId: z.string(),
});

/** @internal */
export const waitForTerminalExitRequestSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  sessionId: sessionIdSchema,
  terminalId: z.string(),
});

/** @internal */
export const killTerminalCommandRequestSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  sessionId: sessionIdSchema,
  terminalId: z.string(),
});

/** @internal */
export const extRequestSchema = z.record(z.union([z.unknown(), z.undefined()]));

/** @internal */
export const permissionOptionSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  kind: permissionOptionKindSchema,
  name: z.string(),
  optionId: permissionOptionIdSchema,
});

/** @internal */
export const toolCallLocationSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  line: z.number().optional().nullable(),
  path: z.string(),
});

/** @internal */
export const annotationsSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  audience: z.array(roleSchema).optional().nullable(),
  lastModified: z.string().optional().nullable(),
  priority: z.number().optional().nullable(),
});

/** @internal */
export const imageContentSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  annotations: annotationsSchema.optional().nullable(),
  data: z.string(),
  mimeType: z.string(),
  uri: z.string().optional().nullable(),
});

/** @internal */
export const audioContentSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  annotations: annotationsSchema.optional().nullable(),
  data: z.string(),
  mimeType: z.string(),
});

/** @internal */
export const resourceLinkSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  annotations: annotationsSchema.optional().nullable(),
  description: z.string().optional().nullable(),
  mimeType: z.string().optional().nullable(),
  name: z.string(),
  size: z.number().optional().nullable(),
  title: z.string().optional().nullable(),
  uri: z.string(),
});

/** @internal */
export const embeddedResourceResourceSchema = z.union([
  textResourceContentsSchema,
  blobResourceContentsSchema,
]);

/** @internal */
export const envVariableSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  name: z.string(),
  value: z.string(),
});

/** @internal */
export const implementationSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  name: z.string(),
  title: z.string().optional().nullable(),
  version: z.string(),
});

/** @internal */
export const authMethodSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  description: z.string().optional().nullable(),
  id: z.string(),
  name: z.string(),
});

/** @internal */
export const mcpCapabilitiesSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  http: z.boolean().optional(),
  sse: z.boolean().optional(),
});

/** @internal */
export const promptCapabilitiesSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  audio: z.boolean().optional(),
  embeddedContext: z.boolean().optional(),
  image: z.boolean().optional(),
});

/** @internal */
export const sessionListCapabilitiesSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
});

/** @internal */
export const modelInfoSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  description: z.string().optional().nullable(),
  modelId: modelIdSchema,
  name: z.string(),
});

/** @internal */
export const sessionModeSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  description: z.string().optional().nullable(),
  id: sessionModeIdSchema,
  name: z.string(),
});

/** @internal */
export const sessionModelStateSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  availableModels: z.array(modelInfoSchema),
  currentModelId: modelIdSchema,
});

/** @internal */
export const sessionModeStateSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  availableModes: z.array(sessionModeSchema),
  currentModeId: sessionModeIdSchema,
});

/** @internal */
export const sessionInfoSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  cwd: z.string(),
  sessionId: sessionIdSchema,
  title: z.string().optional().nullable(),
  updatedAt: z.string().optional().nullable(),
});

/** @internal */
export const promptResponseSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  stopReason: stopReasonSchema,
});

/** @internal */
export const extNotificationSchema = z.record(
  z.union([z.unknown(), z.undefined()]),
);

/** @internal */
export const planEntrySchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  content: z.string(),
  priority: planEntryPrioritySchema,
  status: planEntryStatusSchema,
});

/** @internal */
export const availableCommandInputSchema = unstructuredCommandInputSchema;

/** @internal */
export const authenticateRequestSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  methodId: z.string(),
});

/** @internal */
export const listSessionsRequestSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  cursor: z.string().optional().nullable(),
  cwd: z.string().optional().nullable(),
});

/** @internal */
export const setSessionModeRequestSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  modeId: sessionModeIdSchema,
  sessionId: sessionIdSchema,
});

/** @internal */
export const setSessionModelRequestSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  modelId: modelIdSchema,
  sessionId: sessionIdSchema,
});

/** @internal */
export const fileSystemCapabilitySchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  readTextFile: z.boolean().optional(),
  writeTextFile: z.boolean().optional(),
});

/** @internal */
export const httpHeaderSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  name: z.string(),
  value: z.string(),
});

/** @internal */
export const mcpServerSseSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  headers: z.array(httpHeaderSchema),
  name: z.string(),
  url: z.string(),
});

/** @internal */
export const mcpServerStdioSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  args: z.array(z.string()),
  command: z.string(),
  env: z.array(envVariableSchema),
  name: z.string(),
});

/** @internal */
export const requestPermissionOutcomeSchema = z.union([
  z.object({
    outcome: z.literal("cancelled"),
  }),
  selectedPermissionOutcomeSchema,
]);

/** @internal */
export const terminalExitStatusSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  exitCode: z.number().optional().nullable(),
  signal: z.string().optional().nullable(),
});

/** @internal */
export const cancelNotificationSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  sessionId: sessionIdSchema,
});

/** @internal */
export const clientNotificationSchema = z.object({
  method: z.string(),
  params: z
    .union([cancelNotificationSchema, extNotificationSchema])
    .optional()
    .nullable(),
});

/** @internal */
export const textContentSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  annotations: annotationsSchema.optional().nullable(),
  text: z.string(),
});

/** @internal */
export const embeddedResourceSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  annotations: annotationsSchema.optional().nullable(),
  resource: embeddedResourceResourceSchema,
});

/** @internal */
export const newSessionResponseSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  models: sessionModelStateSchema.optional().nullable(),
  modes: sessionModeStateSchema.optional().nullable(),
  sessionId: sessionIdSchema,
});

/** @internal */
export const loadSessionResponseSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  models: sessionModelStateSchema.optional().nullable(),
  modes: sessionModeStateSchema.optional().nullable(),
});

/** @internal */
export const listSessionsResponseSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  nextCursor: z.string().optional().nullable(),
  sessions: z.array(sessionInfoSchema),
});

/** @internal */
export const planSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  entries: z.array(planEntrySchema),
});

/** @internal */
export const mcpServerHttpSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  headers: z.array(httpHeaderSchema),
  name: z.string(),
  url: z.string(),
});

/** @internal */
export const requestPermissionResponseSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  outcome: requestPermissionOutcomeSchema,
});

/** @internal */
export const terminalOutputResponseSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  exitStatus: terminalExitStatusSchema.optional().nullable(),
  output: z.string(),
  truncated: z.boolean(),
});

/** @internal */
export const createTerminalRequestSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  args: z.array(z.string()).optional(),
  command: z.string(),
  cwd: z.string().optional().nullable(),
  env: z.array(envVariableSchema).optional(),
  outputByteLimit: z.number().optional().nullable(),
  sessionId: sessionIdSchema,
});

/** @internal */
export const contentBlockSchema = z.union([
  textContentSchema,
  imageContentSchema,
  audioContentSchema,
  resourceLinkSchema,
  embeddedResourceSchema,
]);

/** @internal */
export const sessionCapabilitiesSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  list: sessionListCapabilitiesSchema.optional().nullable(),
});

/** @internal */
export const contentChunkSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  content: contentBlockSchema,
});

/** @internal */
export const availableCommandSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  description: z.string(),
  input: availableCommandInputSchema.optional().nullable(),
  name: z.string(),
});

/** @internal */
export const promptRequestSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  prompt: z.array(contentBlockSchema),
  sessionId: sessionIdSchema,
});

/** @internal */
export const clientCapabilitiesSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  fs: fileSystemCapabilitySchema.optional(),
  terminal: z.boolean().optional(),
});

/** @internal */
export const mcpServerSchema = z.union([
  mcpServerHttpSchema,
  mcpServerSseSchema,
  mcpServerStdioSchema,
]);

/** @internal */
export const loadSessionRequestSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  cwd: z.string(),
  mcpServers: z.array(mcpServerSchema),
  sessionId: sessionIdSchema,
});

/** @internal */
export const clientResponseSchema = z.union([
  z.object({
    id: requestIdSchema,
    result: z.union([
      writeTextFileResponseSchema,
      readTextFileResponseSchema,
      requestPermissionResponseSchema,
      createTerminalResponseSchema,
      terminalOutputResponseSchema,
      releaseTerminalResponseSchema,
      waitForTerminalExitResponseSchema,
      killTerminalCommandResponseSchema,
      extResponseSchema,
    ]),
  }),
  z.object({
    error: errorSchema,
    id: requestIdSchema,
  }),
]);

/** @internal */
export const contentSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  content: contentBlockSchema,
});

/** @internal */
export const availableCommandsUpdateSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  availableCommands: z.array(availableCommandSchema),
});

/** @internal */
export const toolCallContentSchema = z.union([
  contentSchema,
  diffSchema,
  terminalSchema,
]);

/** @internal */
export const agentCapabilitiesSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  loadSession: z.boolean().optional(),
  mcpCapabilities: mcpCapabilitiesSchema.optional(),
  promptCapabilities: promptCapabilitiesSchema.optional(),
  sessionCapabilities: sessionCapabilitiesSchema.optional(),
});

/** @internal */
export const toolCallSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  content: z.array(toolCallContentSchema).optional(),
  kind: toolKindSchema.optional(),
  locations: z.array(toolCallLocationSchema).optional(),
  rawInput: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  rawOutput: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  status: toolCallStatusSchema.optional(),
  title: z.string(),
  toolCallId: toolCallIdSchema,
});

/** @internal */
export const initializeRequestSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  clientCapabilities: clientCapabilitiesSchema.optional(),
  clientInfo: implementationSchema.optional().nullable(),
  protocolVersion: protocolVersionSchema,
});

/** @internal */
export const newSessionRequestSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  cwd: z.string(),
  mcpServers: z.array(mcpServerSchema),
});

/** @internal */
export const clientRequestSchema = z.object({
  id: requestIdSchema,
  method: z.string(),
  params: z
    .union([
      initializeRequestSchema,
      authenticateRequestSchema,
      newSessionRequestSchema,
      loadSessionRequestSchema,
      listSessionsRequestSchema,
      setSessionModeRequestSchema,
      promptRequestSchema,
      setSessionModelRequestSchema,
      extRequestSchema,
    ])
    .optional()
    .nullable(),
});

/** @internal */
export const initializeResponseSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  agentCapabilities: agentCapabilitiesSchema.optional(),
  agentInfo: implementationSchema.optional().nullable(),
  authMethods: z.array(authMethodSchema).optional(),
  protocolVersion: protocolVersionSchema,
});

/** @internal */
export const toolCallUpdateSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  content: z.array(toolCallContentSchema).optional().nullable(),
  kind: toolKindSchema.optional().nullable(),
  locations: z.array(toolCallLocationSchema).optional().nullable(),
  rawInput: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  rawOutput: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  status: toolCallStatusSchema.optional().nullable(),
  title: z.string().optional().nullable(),
  toolCallId: toolCallIdSchema,
});

/** @internal */
export const requestPermissionRequestSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  options: z.array(permissionOptionSchema),
  sessionId: sessionIdSchema,
  toolCall: toolCallUpdateSchema,
});

/** @internal */
export const sessionUpdateSchema = z.union([
  contentChunkSchema,
  toolCallSchema,
  toolCallUpdateSchema,
  planSchema,
  availableCommandsUpdateSchema,
  currentModeUpdateSchema,
]);

/** @internal */
export const agentRequestSchema = z.object({
  id: requestIdSchema,
  method: z.string(),
  params: z
    .union([
      writeTextFileRequestSchema,
      readTextFileRequestSchema,
      requestPermissionRequestSchema,
      createTerminalRequestSchema,
      terminalOutputRequestSchema,
      releaseTerminalRequestSchema,
      waitForTerminalExitRequestSchema,
      killTerminalCommandRequestSchema,
      extRequestSchema,
    ])
    .optional()
    .nullable(),
});

/** @internal */
export const agentResponseSchema = z.union([
  z.object({
    id: requestIdSchema,
    result: z.union([
      initializeResponseSchema,
      authenticateResponseSchema,
      newSessionResponseSchema,
      loadSessionResponseSchema,
      listSessionsResponseSchema,
      setSessionModeResponseSchema,
      promptResponseSchema,
      setSessionModelResponseSchema,
      extResponseSchema,
    ]),
  }),
  z.object({
    error: errorSchema,
    id: requestIdSchema,
  }),
]);

/** @internal */
export const sessionNotificationSchema = z.object({
  _meta: z.record(z.union([z.unknown(), z.undefined()])).optional(),
  sessionId: sessionIdSchema,
  update: sessionUpdateSchema,
});

/** @internal */
export const agentNotificationSchema = z.object({
  method: z.string(),
  params: z
    .union([sessionNotificationSchema, extNotificationSchema])
    .optional()
    .nullable(),
});

/** @internal */
export const agentClientProtocolSchema = z.union([
  z.union([agentRequestSchema, agentResponseSchema, agentNotificationSchema]),
  z.union([
    clientRequestSchema,
    clientResponseSchema,
    clientNotificationSchema,
  ]),
]);
